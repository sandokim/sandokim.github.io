---
title: "[3D CV 연구] 3DGS SH2RGB"
last_modified_at: 2024-06-26
categories:
  - 연구
tags:
  - 연구
  - 3D CV
  - 3dgs
  - 3d gaussian splatting
  - implementation details
  - spherical harmonics
  - sh
  - SH2RGB
  - RGB2SH
  - colors
  - SuGaR
  - sh_coordinates
excerpt: "3DGS SH2RGB"
use_math: true
classes: wide
---

# Spherical Harmonics (SH)와 DC 성분

Spherical Harmonics(SH)은 구면 좌표계에서 정의되는 함수의 집합으로, 3D 그래픽스에서 조명, 반사, 음향 등을 표현하는데 사용됩니다. SH 계수는 SH Level에 따라 DC 성분과 나머지 성분으로 나뉩니다.

## DC 성분이란?

- **DC 성분 (Direct Current 성분)**: SH 표현의 가장 기본적인 주파수 성분으로, 상수 함수입니다. 이는 구면에서 모든 방향에 대해 일정한 값을 가지며, 0차 구면 조화 함수로 볼 수 있습니다.
- **역할**:
  - **기본 조명 표현**: 방향에 관계없이 일정한 조명을 나타냅니다.
  - **베이스라인 설정**: 고차 구면 조화 함수와 함께 사용되어 방향에 따른 조명 변화를 더 잘 표현할 수 있도록 합니다.

## SH 계수의 구조

각 SH Level마다 DC 성분과 rest 성분이 존재하며, RGB 채널별로 각각의 계수가 독립적으로 존재합니다.

### Level 0
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 없음
- **총 계수**: 1개의 DC 성분 x 3 (RGB 채널) = 3개

### Level 1
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 3개 (각 RGB 채널마다 3개의 추가 계수)
- **총 계수**: 1개의 DC 성분 + 3개의 rest 성분 = 4개
  - RGB 각각에 대해 4개의 계수 = 4 x 3 = 12개

### Level 2
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 8개 (각 RGB 채널마다 8개의 추가 계수)
- **총 계수**: 1개의 DC 성분 + 8개의 rest 성분 = 9개
  - RGB 각각에 대해 9개의 계수 = 9 x 3 = 27개

### Level 3
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 15개 (각 RGB 채널마다 15개의 추가 계수)
- **총 계수**: 1개의 DC 성분 + 15개의 rest 성분 = 16개
  - RGB 각각에 대해 16개의 계수 = 16 x 3 = 48개

## 요약

- **DC 성분**: 기본적인 SH 성분으로, 모든 방향에서 일정한 값을 가짐.
- **Rest 성분**: DC 성분을 제외한 나머지 고차 SH 성분들.
- **SH Levels와 계수**: 각 Level에 따라 DC 성분을 포함한 총 계수의 수가 결정됨.
- **RGB 채널별 독립적 계수**: ***각 RGB 채널에 대해 SH 계수들이 개별적으로 존재***하여 컬러 정보를 정확히 표현함.

-----

### open3d mesh를 불러와서 initialize하는 법을 알아봅시다.

- surface_mesh_to_bind는 o3d mesh이고
- n_points = surface_mesh_to_bind의 triangle 수 * triangle당 gaussian 수 입니다.
- ***즉, n_points는 triangle들 위에 정의한 gaussian들의 총 개수를 의미합니다.***

```python
    @property
    def n_points(self):
        if not self.binded_to_surface_mesh:
            return len(self._points)
        else:
            return self._n_points
```

### n_points에서 spherical harmonics (sh)의 dc와 rest를 정의하는 코드를 봅시다.

- `colors # shape (n_vertices, n_coords)` 입니다.
- 이때 `n_coords`는 `vertices에 color 정보`입니다!! 정확히 주석을 표현하면 `n_coords`가 아니라 `rgb`로 표시해야 합니다.
- 하지만 `colors`의 rgb 3차원과, `vertices`의 xyz 3차원 정보가 차원이 같아서 주석도 `n_coords`로 통일한 것으로 보입니다.
  ```python
  colors # shape (n_vertices, n_coords) <-- vertices에 대한 rgb 3차원 color 값 = n_coords로 표현
  vertices # shape (n_vertices, n_coords) <-- vertices에 대한 xyz 3차원 좌표값 = n_coords로 표현
  ```
- `colors`에서 `sh_coordinates_dc`를 만드는 과정을 봅시다.
```python
def RGB2SH(rgb):
    return (rgb - 0.5) / C0

def SH2RGB(sh):
    return sh * C0 + 0.5
```
- `sh_coordinates_dc = RGB2SH(colors).unsqueeze(dim=1) # shape (n_vertices, 1, n_coords)`
- 주석을 제대로 쓰면 다음과 같습니다.
- `sh_coordinates_dc = RGB2SH(colors).unsqueeze(dim=1) # shape (n_vertices, 1, rgb)`
- 즉, `마지막 rgb 3개의 차원`에 대해, `sh_coordiantes_dc`는 각각 sh를 1개씩 가지게 됩니다.

- `self._sh_coordinates_rest`는 다음과 같습니다.
- `self._sh_coordinates_rest = torch.zeros(n_points, sh_levels**2 - 1, 3) # shape (n_points, sh_levels**2 - 1, 3)`
- 즉, `마지막 rgb 3개의 차원`에 대해, `self._sh_coordinates_rest`는 각각 `sh_levels**2-1 개`만큼을 가지게 됩니다.
- 즉, `rgb 각 채널별`로 `sh 계수가 할당`됩니다.

```python
        # Initialize color features
        self.sh_levels = sh_levels
        sh_coordinates_dc = RGB2SH(colors).unsqueeze(dim=1)
        self._sh_coordinates_dc = nn.Parameter(
            sh_coordinates_dc.to(self.nerfmodel.device),
            requires_grad=True and (not freeze_gaussians)
        ).to(self.nerfmodel.device)
        
        self._sh_coordinates_rest = nn.Parameter(
            torch.zeros(n_points, sh_levels**2 - 1, 3).to(self.nerfmodel.device),
            requires_grad=True and (not freeze_gaussians)
        ).to(self.nerfmodel.device)
```


```python
# gaussian-splatting/scene/gaussian_model.py

class GaussianModel:

...

    @property
    def get_features(self):
        features_dc = self._features_dc
        features_rest = self._features_rest
        return torch.cat((features_dc, features_rest), dim=1)
```

### 3dgs에서 `_features_dc`, `_features_rest`는 spherical harmonics의 계수에 해댱합니다.

- 따라서 이를 SuGaR에서는 변수이름을 그냥 `_sh_coordinates_dc[...]`, `_sh_coordinates_rest[...]`로 불러와서 사용합니다.

```python
# SuGaR/sugar_extractors/coarse_mesh.py

def extract_mesh_from_coarse_sugar(args):

...


            sugar._sh_coordinates_dc[...] = nerfmodel.gaussians._features_dc.detach()
            sugar._sh_coordinates_rest[...] = nerfmodel.gaussians._features_rest.detach()
    
```

### 3dgs에서 `_features_dc`는 RGB에 해당하는 sh(spherical harmonics)계수입니다.

- 따라서 이를 SuGaR에서는 `SH2RGB` 함수로 sh를 rgb로 변환하여 `colors` 변수에 할당합니다.

```python
# SuGaR/sugar_extractors/coarse_mesh.py

def extract_mesh_from_coarse_sugar(args):

...

        CONSOLE.print(f"\nLoading the coarse SuGaR model from path {sugar_checkpoint_path}...")
        checkpoint = torch.load(sugar_checkpoint_path, map_location=nerfmodel.device)
        colors = SH2RGB(checkpoint['state_dict']['_sh_coordinates_dc'][:, 0, :])
        sugar = SuGaR(
            nerfmodel=nerfmodel,
            points=checkpoint['state_dict']['_points'],
            colors=colors,
            initialize=True,
            sh_levels=nerfmodel.gaussians.active_sh_degree+1,
            keep_track_of_knn=True,
            knn_to_track=16,
            beta_mode='average',  # 'learnable', 'average', 'weighted_average'
            primitive_types='diamond',  # 'diamond', 'square'
            surface_mesh_to_bind=None,  # Open3D mesh
            )
        sugar.load_state_dict(checkpoint['state_dict'])
    sugar.eval()
```

- 그리고 이 `colors`는 불러와서 `RGB2SH`함수로 변환하고 `unsqueeze`하여 차원을 맞춰 학습의 initialize로 줄 수 있습니다.

## SH 계수를 RGB로 변환하기 위해 필요한 정보

SH 계수를 RGB로 변환하기 위해서는 다음의 정보가 필요합니다: `sh의 deg`, `sh의 계수`, `camera center에서 point까지의 direction`.

- SuGaR에서는 `eval_sh(deg, sh, dirs)`를 사용하여 특정 카메라 방향에서 포인트까지의 렌더링 방향에 따라 SH 계수를 하나의 RGB 컬러로 변환합니다.
- RGB 3개의 채널마다 SH 계수가 독립적으로 존재합니다.
- DC는 조명의 전체적인 밝기를 나타내는 상수입니다.

### SH의 DC (0번째 Band)

- `sh[..., 0]`은 0번째 deg에 해당하는 SH의 DC 계수로, 모든 RGB 채널에 대해 동일합니다.

### SH의 Rest (1번째, 2번째, 3번째, ...)

- `sh[..., 1]`부터 `sh[..., 24]`까지의 계수는 각도가 있는 조명 구성 요소입니다.
- SH 계수는 각 RGB 채널에 대해 개별적으로 계산됩니다. 즉, R, G, B 각 채널은 서로 다른 SH 계수를 가질 수 있습니다.

### 예시로 설명

예를 들어, RGB 채널 각각에 대해 SH 계수가 다음과 같이 있을 수 있습니다:

#### R 채널
```python
sh[..., 0] = 0.5
sh[..., 1] = 0.1
sh[..., 2] = 0.3
...
```

#### G 채널
```python
sh[..., 0] = 0.4
sh[..., 1] = 0.2
sh[..., 2] = 0.6
...
```

#### B 채널
```python
sh[..., 0] = 0.7
sh[..., 1] = 0.3
sh[..., 2] = 0.5
...
```

### 각 계수는 각 RGB 채널에 대해 개별적으로 계산됩니다:
- sh[..., 1]은 1번째 deg에 해당하는 SH의 계수로, 각 RGB 채널에 대해 독립적으로 계산된 값을 가집니다.
- sh[..., 2]은 2번째 deg에 해당하는 SH의 계수로, 각 RGB 채널에 대해 독립적으로 계산된 값을 가집니다.
- sh[..., 3]은 3번째 deg에 해당하는 SH의 계수로, 각 RGB 채널에 대해 독립적으로 계산된 값을 가집니다.
- ...
- sh[..., 24]은 24번째 deg에 해당하는 SH의 계수로, 각 RGB 채널에 대해 독립적으로 계산된 값을 가집니다.

#### 요약
- ***SH 계수는 각 RGB 채널에 대해 개별적으로 존재하고, 계산됩니다.***
- 이는 동일한 값을 가진다는 의미가 아니며, 각 채널별로 다른 값을 가질 수 있습니다.
- **각 채널의 SH 계수는 개별적으로 처리되며, eval_sh 함수는 각 채널에 대해 독립적으로 SH 계수를 사용하여 RGB 값을 계산합니다.**


```python
# SuGaR/sugar_scene/sugar_model.py

    def get_points_rgb(
        self,
        positions:torch.Tensor=None,
        camera_centers:torch.Tensor=None,
        directions:torch.Tensor=None,
        sh_levels:int=None,
        sh_coordinates:torch.Tensor=None,
        ):
        """Returns the RGB color of the points for the given camera pose.

        Args:
            positions (torch.Tensor, optional): Shape (n_pts, 3). Defaults to None.
            camera_centers (torch.Tensor, optional): Shape (n_pts, 3) or (1, 3). Defaults to None.
            directions (torch.Tensor, optional): _description_. Defaults to None.

        Raises:
            ValueError: _description_

        Returns:
            _type_: _description_
        """
            
        if positions is None:
            positions = self.points

        if camera_centers is not None:
            render_directions = torch.nn.functional.normalize(positions - camera_centers, dim=-1)
        elif directions is not None:
            render_directions = directions
        else:
            raise ValueError("Either camera_centers or directions must be provided.")

        if sh_coordinates is None:
            sh_coordinates = self.sh_coordinates
            
        if sh_levels is None:
            sh_coordinates = sh_coordinates
        else:
            sh_coordinates = sh_coordinates[:, :sh_levels**2]

        shs_view = sh_coordinates.transpose(-1, -2).view(-1, 3, sh_levels**2)
        sh2rgb = eval_sh(sh_levels-1, shs_view, render_directions)
        colors = torch.clamp_min(sh2rgb + 0.5, 0.0).view(-1, 3)
        
        return colors
```

```python
# SuGaR/sugar_utils/spherical_harmonics.py

def eval_sh(deg, sh, dirs):
    """
    Evaluate spherical harmonics at unit directions
    using hardcoded SH polynomials.
    Works with torch/np/jnp.
    ... Can be 0 or more batch dimensions.
    Args:
        deg: int SH deg. Currently, 0-3 supported
        sh: jnp.ndarray SH coeffs [..., C, (deg + 1) ** 2]
        dirs: jnp.ndarray unit directions [..., 3]
    Returns:
        [..., C]
    """
    assert deg <= 4 and deg >= 0
    coeff = (deg + 1) ** 2
    assert sh.shape[-1] >= coeff

    result = C0 * sh[..., 0]
    if deg > 0:
        x, y, z = dirs[..., 0:1], dirs[..., 1:2], dirs[..., 2:3]
        result = (result -
                C1 * y * sh[..., 1] +
                C1 * z * sh[..., 2] -
                C1 * x * sh[..., 3])

        if deg > 1:
            xx, yy, zz = x * x, y * y, z * z
            xy, yz, xz = x * y, y * z, x * z
            result = (result +
                    C2[0] * xy * sh[..., 4] +
                    C2[1] * yz * sh[..., 5] +
                    C2[2] * (2.0 * zz - xx - yy) * sh[..., 6] +
                    C2[3] * xz * sh[..., 7] +
                    C2[4] * (xx - yy) * sh[..., 8])

            if deg > 2:
                result = (result +
                C3[0] * y * (3 * xx - yy) * sh[..., 9] +
                C3[1] * xy * z * sh[..., 10] +
                C3[2] * y * (4 * zz - xx - yy)* sh[..., 11] +
                C3[3] * z * (2 * zz - 3 * xx - 3 * yy) * sh[..., 12] +
                C3[4] * x * (4 * zz - xx - yy) * sh[..., 13] +
                C3[5] * z * (xx - yy) * sh[..., 14] +
                C3[6] * x * (xx - 3 * yy) * sh[..., 15])

                if deg > 3:
                    result = (result + C4[0] * xy * (xx - yy) * sh[..., 16] +
                            C4[1] * yz * (3 * xx - yy) * sh[..., 17] +
                            C4[2] * xy * (7 * zz - 1) * sh[..., 18] +
                            C4[3] * yz * (7 * zz - 3) * sh[..., 19] +
                            C4[4] * (zz * (35 * zz - 30) + 3) * sh[..., 20] +
                            C4[5] * xz * (7 * zz - 3) * sh[..., 21] +
                            C4[6] * (xx - yy) * (7 * zz - 1) * sh[..., 22] +
                            C4[7] * xz * (xx - 3 * yy) * sh[..., 23] +
                            C4[8] * (xx * (xx - 3 * yy) - yy * (3 * xx - yy)) * sh[..., 24])
    return result

def RGB2SH(rgb):
    return (rgb - 0.5) / C0

def SH2RGB(sh):
    return sh * C0 + 0.5

```







### maps=SH2RGB(self.texture_features[..., 0, :][None])

```python
textures_uv = TexturesUV(
            maps=SH2RGB(self.texture_features[..., 0, :][None]), #texture_img[None]),
            verts_uvs=self.verts_uv[None],
            faces_uvs=self.faces_uv[None],
            sampling_mode='nearest',
            )
```

[https://sandokim.github.io/%EC%97%B0%EA%B5%AC/3dgs-mesh/]([3D CV 연구] 3DGS input & output .ply properties & Meshlab Vert & Spherical Harmonics (SH) & Mesh)

