---
title: "[3D CV 연구] 3DGS SH2RGB"
last_modified_at: 2024-06-26
categories:
  - 연구
tags:
  - 연구
  - 3D CV
  - 3dgs
  - 3d gaussian splatting
  - implementation details
  - spherical harmonics
  - sh
  - SH2RGB
  - colors
  - SuGaR
  - sh_coordinates
excerpt: "3DGS SH2RGB"
use_math: true
classes: wide
---

# Spherical Harmonics (SH)와 DC 성분

Spherical Harmonics(SH)은 구면 좌표계에서 정의되는 함수의 집합으로, 3D 그래픽스에서 조명, 반사, 음향 등을 표현하는데 사용됩니다. SH 계수는 SH Level에 따라 DC 성분과 나머지 성분으로 나뉩니다.

## DC 성분이란?

- **DC 성분 (Direct Current 성분)**: SH 표현의 가장 기본적인 주파수 성분으로, 상수 함수입니다. 이는 구면에서 모든 방향에 대해 일정한 값을 가지며, 0차 구면 조화 함수로 볼 수 있습니다.
- **역할**:
  - **기본 조명 표현**: 방향에 관계없이 일정한 조명을 나타냅니다.
  - **베이스라인 설정**: 고차 구면 조화 함수와 함께 사용되어 방향에 따른 조명 변화를 더 잘 표현할 수 있도록 합니다.

## SH 계수의 구조

각 SH Level마다 DC 성분과 rest 성분이 존재하며, RGB 채널별로 각각의 계수가 독립적으로 존재합니다.

### Level 0
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 없음
- **총 계수**: 1개의 DC 성분 x 3 (RGB 채널) = 3개

### Level 1
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 3개 (각 RGB 채널마다 3개의 추가 계수)
- **총 계수**: 1개의 DC 성분 + 3개의 rest 성분 = 4개
  - RGB 각각에 대해 4개의 계수 = 4 x 3 = 12개

### Level 2
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 8개 (각 RGB 채널마다 8개의 추가 계수)
- **총 계수**: 1개의 DC 성분 + 8개의 rest 성분 = 9개
  - RGB 각각에 대해 9개의 계수 = 9 x 3 = 27개

### Level 3
- **DC 성분**: 1개 (RGB 각각 1개씩 총 3개)
- **Rest 성분**: 15개 (각 RGB 채널마다 15개의 추가 계수)
- **총 계수**: 1개의 DC 성분 + 15개의 rest 성분 = 16개
  - RGB 각각에 대해 16개의 계수 = 16 x 3 = 48개

## 요약

- **DC 성분**: 기본적인 SH 성분으로, 모든 방향에서 일정한 값을 가짐.
- **Rest 성분**: DC 성분을 제외한 나머지 고차 SH 성분들.
- **SH Levels와 계수**: 각 Level에 따라 DC 성분을 포함한 총 계수의 수가 결정됨.
- **RGB 채널별 독립적 계수**: ***각 RGB 채널에 대해 SH 계수들이 개별적으로 존재***하여 컬러 정보를 정확히 표현함.

-----

### open3d mesh를 불러와서 initialize하는 법을 알아봅시다.

- surface_mesh_to_bind는 o3d mesh이고
- n_points = surface_mesh_to_bind의 triangle 수 * triangle당 gaussian 수 입니다.
- ***즉, n_points는 triangle들 위에 정의한 gaussian들의 총 개수를 의미합니다.***

```python
    @property
    def n_points(self):
        if not self.binded_to_surface_mesh:
            return len(self._points)
        else:
            return self._n_points
```

### n_points에서 spherical harmonics (sh)의 dc와 rest를 정의하는 코드를 봅시다.

- `colors # shape (n_vertices, n_coords)` 입니다.
- 이때 `n_coords`는 `vertices에 color 정보`입니다!! 정확히 주석을 표현하면 `n_coords`가 아니라 `rgb`로 표시해야 합니다.
- 하지만 `colors`의 rgb 3차원과, `vertices`의 xyz 3차원 정보가 차원이 같아서 주석도 `n_coords`로 통일한 것으로 보입니다.
  ```python
  colors # shape (n_vertices, n_coords) <-- vertices에 대한 rgb 3차원 color 값 = n_coords로 표현
  vertices # shape (n_vertices, n_coords) <-- vertices에 대한 xyz 3차원 좌표값 = n_coords로 표현
  ```
- `colors`에서 `sh_coordinates_dc`를 만드는 과정을 봅시다.
```python
def RGB2SH(rgb):
    return (rgb - 0.5) / C0

def SH2RGB(sh):
    return sh * C0 + 0.5
```
- `sh_coordinates_dc = RGB2SH(colors).unsqueeze(dim=1) # shape (n_vertices, 1, n_coords)`
- 주석을 제대로 쓰면 다음과 같습니다.
- `sh_coordinates_dc = RGB2SH(colors).unsqueeze(dim=1) # shape (n_vertices, 1, rgb)`
- 즉, `마지막 rgb 3개의 차원`에 대해, `sh_coordiantes_dc`는 각각 sh를 1개씩 가지게 됩니다.

- `self._sh_coordinates_rest`는 다음과 같습니다.
- `self._sh_coordinates_rest = torch.zeros(n_points, sh_levels**2 - 1, 3) # shape (n_points, sh_levels**2 - 1, 3)`
- 즉, `마지막 rgb 3개의 차원`에 대해, `self._sh_coordinates_rest`는 각각 `sh_levels**2-1 개`만큼을 가지게 됩니다.
- 즉, `rgb 각 채널별`로 `sh 계수가 할당`됩니다.

```python
        # Initialize color features
        self.sh_levels = sh_levels
        sh_coordinates_dc = RGB2SH(colors).unsqueeze(dim=1)
        self._sh_coordinates_dc = nn.Parameter(
            sh_coordinates_dc.to(self.nerfmodel.device),
            requires_grad=True and (not freeze_gaussians)
        ).to(self.nerfmodel.device)
        
        self._sh_coordinates_rest = nn.Parameter(
            torch.zeros(n_points, sh_levels**2 - 1, 3).to(self.nerfmodel.device),
            requires_grad=True and (not freeze_gaussians)
        ).to(self.nerfmodel.device)
```


```python
# gaussian-splatting/scene/gaussian_model.py

class GaussianModel:

...

    @property
    def get_features(self):
        features_dc = self._features_dc
        features_rest = self._features_rest
        return torch.cat((features_dc, features_rest), dim=1)
```

### 3dgs에서 `_features_dc`, `_features_rest`는 spherical harmonics의 계수에 해댱합니다.

- 따라서 이를 SuGaR에서는 변수이름을 그냥 `_sh_coordinates_dc[...]`, `_sh_coordinates_rest[...]`로 불러와서 사용합니다.

```python
# SuGaR/sugar_extractors/coarse_mesh.py

def extract_mesh_from_coarse_sugar(args):

...


            sugar._sh_coordinates_dc[...] = nerfmodel.gaussians._features_dc.detach()
            sugar._sh_coordinates_rest[...] = nerfmodel.gaussians._features_rest.detach()
    
```

### 3dgs에서 `_features_dc`는 RGB에 해당하는 sh(spherical harmonics)계수입니다.

- 따라서 이를 SuGaR에서는 `SH2RGB` 함수로 sh를 rgb로 변환하여 `colors` 변수에 할당합니다.

```python
# SuGaR/sugar_extractors/coarse_mesh.py

def extract_mesh_from_coarse_sugar(args):

...

        CONSOLE.print(f"\nLoading the coarse SuGaR model from path {sugar_checkpoint_path}...")
        checkpoint = torch.load(sugar_checkpoint_path, map_location=nerfmodel.device)
        colors = SH2RGB(checkpoint['state_dict']['_sh_coordinates_dc'][:, 0, :])
        sugar = SuGaR(
            nerfmodel=nerfmodel,
            points=checkpoint['state_dict']['_points'],
            colors=colors,
            initialize=True,
            sh_levels=nerfmodel.gaussians.active_sh_degree+1,
            keep_track_of_knn=True,
            knn_to_track=16,
            beta_mode='average',  # 'learnable', 'average', 'weighted_average'
            primitive_types='diamond',  # 'diamond', 'square'
            surface_mesh_to_bind=None,  # Open3D mesh
            )
        sugar.load_state_dict(checkpoint['state_dict'])
    sugar.eval()
```

- 그리고 이 `colors`는 불러와서 `RGB2SH`함수로 변한하고 `unsqueeze`하여 차원을 맞춰 학습의 initialize로 줄 수 있습니다.


