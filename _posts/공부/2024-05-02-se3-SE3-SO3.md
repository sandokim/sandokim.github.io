---
title: "[3D CV] se3, SE3. SO3"
last_modified_at: 2024-05-02
categories:
  - 공부
tags:
  - Lie Algebra
  - Lie Group
  - se3
  - SE3
  - SO3
excerpt: "Lie Algebra & Lie Group 정리"
use_math: true
classes: wide
---

> [[Blog](https://jaehoon-daddy.tistory.com/40)] 

본 포스트는 위 블로그 내용을 참조하여 정리한 내용임을 밝힙니다.

### SO(3)

$$SO(3) = \{ R \in \mathbb{R}^{3 \times 3} | R^T R = I, \text{det}(R) = 1 \}$$

여기서 $R$은 3x3 직교 행렬이며, $R^T$는 $R$의 전치 행렬을 나타냅니다. 이 그룹은 회전을 나타내며, 회전 행렬은 직교 행렬이며 행렬식이 1입니다.

### SE(3)

$$SE(3) = \{ T \in \mathbb{R}^{4 \times 4} | T = \begin{bmatrix} R & t \\ 0 & 1 \end{bmatrix}, R \in SO(3), t \in \mathbb{R}^3 \}$$

여기서 $T$는 4x4 변환 행렬을 나타내며, $R$은 회전 행렬, $t$은 이동 벡터를 나타냅니다. 이 그룹은 이동과 회전을 결합한 변환을 나타내며, 변환 행렬은 직교 행렬과 이동 벡터로 구성됩니다.

### se(3)

$$se(3) = \{ \xi \in \mathbb{R}^6 | \xi = \begin{bmatrix} \omega \\ v \end{bmatrix}, \omega, v \in \mathbb{R}^3 \}$$

여기서 $\xi$는 6차원 벡터이며, $\omega$는 회전 속도 벡터, $v$는 이동 속도 벡터를 나타냅니다. 이 그룹은 작은 회전과 작은 이동을 나타내는 벡터 공간으로, SE(3) 그룹에서의 작은 변환을 나타냅니다.


## se3에서 SE3로의 변환 함수 설명

### 함수 `skew_symmetric(w)`
- **입력:** 각속도 벡터 `w`
- **출력:** `w`의 스큐 대칭 행렬(skew-symmetric matrix)
- **설명:** 각속도 벡터를 입력받아 해당 벡터의 스큐 대칭 행렬을 생성합니다. 이 행렬은 벡터의 외적을 행렬 곱셈으로 표현할 수 있게 해 줍니다.

### 함수 `taylor_A(x, nth=10)`, `taylor_B(x, nth=10)`, `taylor_C(x, nth=10)`
- **입력:** 스칼라 또는 벡터 `x`, 급수의 항수 `nth`
- **출력:** 테일러 급수로 근사된 각각의 함수 값
- **설명:** 각 함수는 로드리게스 회전 공식(Rodrigues' rotation formula)에서 사용되는 sin(x)/x, (1-cos(x))/x^2, (x-sin(x))/x^3 등을 근사합니다. 이러한 근사는 회전의 크기가 작을 때 더욱 정확하게 동작합니다.

### 함수 `se3_to_SE3(w, v)`
- **입력:** 각속도 벡터 `w`, 선속도 벡터 `v`
- **출력:** 4x4 변환 행렬 `SE3`
- **설명:** 입력된 `w`와 `v`로부터 SE3 변환 행렬을 계산합니다. 이 행렬은 3D 공간에서의 리지드 바디 변환(rigid body transformation)을 표현하며, 회전과 이동을 모두 포함합니다.
  - 상위 3x3 부분은 회전을 나타내며, 로드리게스 공식과 테일러 급수 근사를 통해 계산됩니다.
  - 마지막 열의 상위 3개 요소는 이동을 나타내며, 회전을 고려한 테일러 급수 근사를 통해 계산됩니다.
  - 매트릭스(matrix)의 오른쪽 아래 요소는 항상 1입니다.

```python
import torch

def skew_symmetric(w):
    # 각속도 벡터 성분 분해
    w0, w1, w2 = w.unbind(dim=-1)
    O = torch.zeros_like(w0)
    # 스큐 대칭 행렬 생성
    wx = torch.stack([torch.stack([O, -w2, w1], dim=-1),
                      torch.stack([w2, O, -w0], dim=-1),
                      torch.stack([-w1, w0, O], dim=-1)], dim=-2)
    return wx

def taylor_A(x, nth=10):
    # sin(x)/x의 테일러 급수 근사
    ans = torch.zeros_like(x)
    denom = 1.
    for i in range(nth+1):
        if i > 0: denom *= (2*i)*(2*i+1)
        ans += (-1)**i * x**(2*i) / denom
    return ans
    
def taylor_B(x, nth=10):
    # (1-cos(x))/x^2의 테일러 급수 근사
    ans = torch.zeros_like(x)
    denom = 1.
    for i in range(nth+1):
        denom *= (2*i+1)*(2*i+2)
        ans += (-1)**i * x**(2*i) / denom
    return ans

def taylor_C(x, nth=10):
    # (x-sin(x))/x^3의 테일러 급수 근사
    ans = torch.zeros_like(x)
    denom = 1.
    for i in range(nth+1):
        denom *= (2*i+2)*(2*i+3)
        ans += (-1)**i * x**(2*i) / denom
    return ans

def se3_to_SE3(w, v):  # [...,3] 형태의 입력 벡터
    deltaT = torch.zeros((4,4)).cuda()  # GPU에서 0 행렬 초기화
    wx = skew_symmetric(w)  # 각속도의 스큐 대칭 행렬 계산
    theta = w.norm(dim=-1)  # 각속도 벡터의 크기 계산
    I = torch.eye(3, device=w.device, dtype=torch.float32)  # 단위 행렬
    A = taylor_A(theta)  # A 급수 계산
    B = taylor_B(theta)  # B 급수 계산
    C = taylor_C(theta)  # C 급수 계산
    deltaT[:3, :3] = I + A*wx + B*wx@wx  # SE3의 회전 부분 설정
    V = I + B*wx + C*wx@wx  # 이동 부분 조정을 위한 행렬 V 계산
    deltaT[:3, 3] = V@v  # SE3의 이동 부분 설정
    deltaT[3, 3] = 1.  # 동차 좌표
    return deltaT
```


